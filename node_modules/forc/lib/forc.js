'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = forc;

require('babel-regenerator-runtime');

var _pairs = require('./utils/pairs');

var _pairs2 = _interopRequireDefault(_pairs);

var _resolve = require('./utils/resolve');

var _resolve2 = _interopRequireDefault(_resolve);

var _applyLets = require('./utils/applyLets');

var _applyLets2 = _interopRequireDefault(_applyLets);

var _typeChecks = require('./utils/typeChecks');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

var _marked = [forc, states].map(regeneratorRuntime.mark);

function forc(seq, body) {
  var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, state;

  return regeneratorRuntime.wrap(function forc$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if ((0, _typeChecks.isIterable)(seq)) {
            _context.next = 2;
            break;
          }

          throw new Error('The first argument must be iterable');

        case 2:
          if ((0, _typeChecks.isFunction)(body)) {
            _context.next = 4;
            break;
          }

          throw new Error('The second argument must be a function');

        case 4:
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 7;
          _iterator = states((0, _pairs2.default)(seq))[Symbol.iterator]();

        case 9:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 16;
            break;
          }

          state = _step.value;
          _context.next = 13;
          return body(state);

        case 13:
          _iteratorNormalCompletion = true;
          _context.next = 9;
          break;

        case 16:
          _context.next = 22;
          break;

        case 18:
          _context.prev = 18;
          _context.t0 = _context['catch'](7);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 22:
          _context.prev = 22;
          _context.prev = 23;

          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }

        case 25:
          _context.prev = 25;

          if (!_didIteratorError) {
            _context.next = 28;
            break;
          }

          throw _iteratorError;

        case 28:
          return _context.finish(25);

        case 29:
          return _context.finish(22);

        case 30:
        case 'end':
          return _context.stop();
      }
    }
  }, _marked[0], this, [[7, 18, 22, 30], [23,, 25, 29]]);
}

// TODO: Rewrite this function to a little more elegant.
function states(paired, state) {
  var _paired, head, tail, _head, key, value, iter, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, item, stop;

  return regeneratorRuntime.wrap(function states$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _paired = _toArray(paired);
          head = _paired[0];
          tail = _paired.slice(1);

          if (!head) {
            _context2.next = 60;
            break;
          }

          state = state || {};

          _head = _slicedToArray(head, 2);
          key = _head[0];
          value = _head[1];

          if (!(key === ':let')) {
            _context2.next = 13;
            break;
          }

          return _context2.delegateYield(states(tail, (0, _applyLets2.default)(value, state)), 't0', 10);

        case 10:
          return _context2.abrupt('return', _context2.t0);

        case 13:
          if (!(key === ':when')) {
            _context2.next = 19;
            break;
          }

          if (!(0, _resolve2.default)(value, state)) {
            _context2.next = 17;
            break;
          }

          return _context2.delegateYield(states(tail, state), 't1', 16);

        case 16:
          return _context2.abrupt('return', _context2.t1);

        case 17:
          _context2.next = 58;
          break;

        case 19:
          if (!(key === ':while')) {
            _context2.next = 28;
            break;
          }

          if (!(0, _resolve2.default)(value, state)) {
            _context2.next = 25;
            break;
          }

          return _context2.delegateYield(states(tail, state), 't2', 22);

        case 22:
          return _context2.abrupt('return', _context2.t2);

        case 25:
          return _context2.abrupt('return', true);

        case 26:
          _context2.next = 58;
          break;

        case 28:
          iter = (0, _resolve2.default)(value, state);
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context2.prev = 32;
          _iterator2 = iter[Symbol.iterator]();

        case 34:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context2.next = 44;
            break;
          }

          item = _step2.value;

          state[key] = item;
          return _context2.delegateYield(states(tail, state), 't3', 38);

        case 38:
          stop = _context2.t3;

          if (!(stop === true)) {
            _context2.next = 41;
            break;
          }

          return _context2.abrupt('return', stop);

        case 41:
          _iteratorNormalCompletion2 = true;
          _context2.next = 34;
          break;

        case 44:
          _context2.next = 50;
          break;

        case 46:
          _context2.prev = 46;
          _context2.t4 = _context2['catch'](32);
          _didIteratorError2 = true;
          _iteratorError2 = _context2.t4;

        case 50:
          _context2.prev = 50;
          _context2.prev = 51;

          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }

        case 53:
          _context2.prev = 53;

          if (!_didIteratorError2) {
            _context2.next = 56;
            break;
          }

          throw _iteratorError2;

        case 56:
          return _context2.finish(53);

        case 57:
          return _context2.finish(50);

        case 58:
          _context2.next = 64;
          break;

        case 60:
          if (!state) {
            _context2.next = 64;
            break;
          }

          _context2.next = 63;
          return state;

        case 63:
          return _context2.abrupt('return', _context2.sent);

        case 64:
        case 'end':
          return _context2.stop();
      }
    }
  }, _marked[1], this, [[32, 46, 50, 58], [51,, 53, 57]]);
}